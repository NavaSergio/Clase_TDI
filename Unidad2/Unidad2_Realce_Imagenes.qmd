---
title: "Unidad 2 ‚Äì Realce y Restauraci√≥n de Im√°genes"
subtitle: "Tratamiento Digital de Im√°genes"
author: 
  - name: Sergio M. Nava Mu√±oz
    id: sn
    email: s3rgio.nava@gmail.com
    affiliation: 
        - id: cimat
          name: CIMAT/INFOTEC
          city: Aguascalientes
          state: Ags
format: 
  revealjs:
    slide-number: true
    theme: simple
    fontsize: 2.1em
    logo: figs/logo-infotec.jpeg
    css: style.css
    chalkboard: true
    menu: TRUE
    transition: slide
    background-transition: fade
    title-slide-attributes:
      data-background-image: /figs/DCCD.png
      data-background-size: 100% 100%;     
date: 2025-02-19
---

## Fin de aprendizaje

- Aplicar t√©cnicas de mejora y restauraci√≥n de im√°genes digitales.  
- Utilizar operaciones matriciales y filtros en OpenCV.  
- Comprender fundamentos matem√°ticos de histogramas y filtrado.  
- Preparar im√°genes para tareas avanzadas de an√°lisis visual.  

---

## Introducci√≥n

- El realce mejora la apariencia **visual** de las im√°genes.  
- Facilita tareas como:  
  - Detecci√≥n de objetos  
  - Reconocimiento de texturas (ej. im√°genes m√©dicas)  
  - Segmentaci√≥n y clasificaci√≥n  

---



## Descomposici√≥n en canales RGB

- Una imagen en color puede verse como **tres matrices en escala de grises**:  
  - **Canal R (Rojo)**  
  - **Canal G (Verde)**  
  - **Canal B (Azul)**  

- Cada canal almacena intensidades entre 0 y 255.  
- La combinaci√≥n de los tres forma la imagen en color.  

<div style="display:flex; gap:30px; justify-content:center; align-items:center;">

  <div style="text-align:center;">
    <img src="canal_R.png" width="180"><br>
    <b>Canal R</b>
  </div>

  <div style="text-align:center;">
    <img src="canal_G.png" width="180"><br>
    <b>Canal G</b>
  </div>

  <div style="text-align:center;">
    <img src="canal_B.png" width="180"><br>
    <b>Canal B</b>
  </div>

</div>

<div style="text-align:center; margin-top:15px;">
  <img src="imagen_RGB.png" width="220"><br>
  <b>Imagen combinada</b>
</div>

---

## Representaci√≥n de im√°genes

- Una imagen digital en escala de grises puede representarse como una **matriz** $I$ de tama√±o $M \times N$:  

$$
I = \begin{bmatrix}
i_{11} & i_{12} & \cdots & i_{1N} \\
i_{21} & i_{22} & \cdots & i_{2N} \\
\vdots & \vdots & \ddots & \vdots \\
i_{M1} & i_{M2} & \cdots & i_{MN}
\end{bmatrix}
$$

- Cada elemento $i_{mn}$ es un valor de **intensidad** (0‚Äì255 en im√°genes de 8 bits).


---

## Visualizaci√≥n de un patch en RGB y sus canales

```{python}
import cv2
import matplotlib.pyplot as plt
import numpy as np
from IPython.display import display, Markdown

# Cargar imagen en color (OpenCV usa BGR)
img_bgr = cv2.imread("imagenes/frutas.jpg", cv2.IMREAD_COLOR)
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)

# Seleccionar un patch peque√±o (5x5 p√≠xeles)
patch = img_rgb[0:5, 0:5, :]

# Separar los canales
R = patch[:,:,0]
G = patch[:,:,1]
B = patch[:,:,2]

# Mostrar el patch en color y guardarlo
plt.figure(figsize=(2.5,2.5))
plt.imshow(patch)
plt.axis('off')
plt.title("Patch 5x5 RGB")
plt.savefig("patch_rgb.png", bbox_inches="tight")
plt.close()

# Convertir las matrices a strings
R_str = np.array2string(R, max_line_width=40)
G_str = np.array2string(G, max_line_width=40)
B_str = np.array2string(B, max_line_width=40)
# Mostrar en formato columnas
display(Markdown(f"""
<div style="display:flex; gap:25px;">
<div style="font-size:15px; white-space:pre;">
<b>Canal R</b><br>{R_str}<br><br>
<b>Canal G</b><br>{G_str}<br><br>
<b>Canal B</b><br>{B_str}<br><br>
<b>Juntos</b><br>{patch}
</div>
<div style="flex:1; text-align:center;">
<img src='patch_rgb.png' style="width:100%; height:auto;">
</div>

</div>
"""))

```

---


## Mezcla aditiva de colores ‚Äì Modelo RGB {.smaller}

::: {.columns}
::: {.column width="50%"}
![RGB color model venn diagram](https://tse4.mm.bing.net/th/id/OIP.LGzz_j3Bt826nHdzSRywlQHaHa?r=0&pid=Api){width=350}
:::

::: {.column width="50%" }
**Explicaci√≥n:**

- El modelo **RGB** (Red, Green, Blue) es **aditivo**.  
- Combinaciones:  
  - Rojo + Verde = Amarillo  
  - Verde + Azul = Cian  
  - Azul + Rojo = Magenta  
  - Rojo + Verde + Azul (m√°xima intensidad) = Blanco  
- Cada canal var√≠a de **0 a 255**, permitiendo representar millones de colores.  
- Es el modelo usado en **pantallas, c√°maras y procesamiento digital de im√°genes**.
:::
:::


---

## Visualizaci√≥n de valores en escala de grises

```{python}
import cv2
import matplotlib.pyplot as plt
import numpy as np

# Cargar imagen en escala de grises
img = cv2.imread("imagenes/frutas.jpg", cv2.IMREAD_GRAYSCALE)

# Seleccionar una secci√≥n peque√±a (ej. 10x10 p√≠xeles desde la esquina superior izquierda)
patch = img[0:10, 0:10]

# Mostrar la secci√≥n ampliada como imagen
plt.figure(figsize=(3,3))
plt.imshow(patch, cmap='gray', vmin=0, vmax=255)
plt.title("Secci√≥n 10x10 en escala de grises")
plt.axis('off')
plt.show()

# Convertir la matriz a string
matriz_str = np.array2string(patch, max_line_width=80)

# Mostrar en formato markdown con letra peque√±a
from IPython.display import display, Markdown
display(Markdown(f"<pre style='font-size:15px'>{matriz_str}</pre>"))

```

---

## Histograma de una imagen

- El histograma es la **frecuencia de aparici√≥n de intensidades**.  
- Formalmente:  

$$
h(r_k) = n_k
$$

donde $r_k$ es un nivel de gris y $n_k$ el n√∫mero de p√≠xeles con ese valor.  

---

### C√≥digo: Construcci√≥n del histograma

```{python}
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Cargar imagen en escala de grises
img = cv2.imread( "imagenes/frutas.jpg", cv2.IMREAD_GRAYSCALE)
crop = img[:256, :256]

# Calcular histograma con OpenCV
hist = cv2.calcHist([crop], [0], None, [256], [0,256])


plt.figure(figsize=(6,4))
plt.bar(np.arange(256), hist.flatten(), color='gray')
plt.title("Histograma manual")
plt.xlabel("Intensidad")
plt.ylabel("Frecuencia")
plt.show()
```

---

## Ecualizaci√≥n de histograma

- Busca redistribuir los niveles de gris para mejorar el contraste.  
- Funci√≥n de transformaci√≥n acumulativa:  

$$
s_k = (L-1)\sum_{j=0}^k \frac{n_j}{MN}
$$

donde:  
- $L$ = n√∫mero de niveles (256 en 8 bits).  
- $M \times N$ = n√∫mero total de p√≠xeles.  

---

### C√≥digo: Ecualizaci√≥n con OpenCV

```{python}
# Ecualizaci√≥n de histograma
eq = cv2.equalizeHist(crop)

# Mostrar comparaci√≥n
plt.figure(figsize=(10,4))
plt.subplot(1,2,1)
plt.imshow(crop, cmap='gray')
plt.title("Imagen original")
plt.axis('off')

plt.subplot(1,2,2)
plt.imshow(eq, cmap='gray')
plt.title("Imagen ecualizada")
plt.axis('off')
plt.show()
```

---

## Filtrado espacial

- Consiste en aplicar una **m√°scara o kernel** $H$ a la imagen:  

$$
g(x,y) = \sum_{s=-a}^{a} \sum_{t=-b}^{b} H(s,t) \cdot f(x+s, y+t)
$$

- Donde:  
  - $f(x,y)$ = imagen original  
  - $g(x,y)$ = imagen filtrada  
  - $H$ = kernel de tama√±o $(2a+1) \times (2b+1)$  

---

### Ejemplo de kernel promedio 3x3

$$
H = \frac{1}{9}
\begin{bmatrix}
1 & 1 & 1 \\
1 & 1 & 1 \\
1 & 1 & 1
\end{bmatrix}
$$


---

## Filtro Promedio (Blur)

- El valor del p√≠xel se reemplaza por el **promedio aritm√©tico** de los p√≠xeles en una ventana \(k \times k\).  

\[
g(x,y) = \frac{1}{k^2} \sum_{s=-a}^{a} \sum_{t=-b}^{b} f(x+s, y+t)
\]

- Kernel:

\[
H = \frac{1}{k^2}
\begin{bmatrix}
1 & 1 & \cdots & 1 \\
1 & 1 & \cdots & 1 \\
\vdots & \vdots & \ddots & \vdots \\
1 & 1 & \cdots & 1
\end{bmatrix}
\]

---

## Filtro Gaussiano

- Utiliza una funci√≥n **Gaussiana bidimensional** como kernel.  

\[
G(s,t) = \frac{1}{2\pi\sigma^2} \exp\left(-\frac{s^2+t^2}{2\sigma^2}\right)
\]

- Operaci√≥n de filtrado:

\[
g(x,y) = \sum_{s=-a}^{a} \sum_{t=-b}^{b} G(s,t)\, f(x+s, y+t)
\]

- Normalizado:  

\[
\sum_{s,t} G(s,t) = 1
\]

---

## Filtro de Mediana

- Es un m√©todo **no lineal**.  
- En una ventana \(k \times k\), reemplaza el valor del p√≠xel por la **mediana** de los valores en esa ventana.  

\[
g(x,y) = \operatorname{mediana}\{ f(x+s, y+t) \mid -a \leq s,t \leq a \}
\]

- Preserva bordes mejor que los filtros lineales.  
- Muy eficaz contra ruido impulsivo ("sal y pimienta").  

---

## Resumen Comparativo

| Filtro     | F√≥rmula | Naturaleza | Ventajas | Desventajas |
|------------|---------|------------|----------|-------------|
| **Promedio (Blur)** | Promedio aritm√©tico | Lineal | Simple, r√°pido | Borra bordes y detalles |
| **Gaussiano** | Ponderaci√≥n con distribuci√≥n normal | Lineal | Suavizado natural, controlado por \(\sigma\) | M√°s costoso computacionalmente |
| **Mediana** | Mediana de intensidades | No lineal | Preserva bordes, elimina ruido impulsivo | Menos eficiente en ventanas grandes |


---

### C√≥digo: Filtros en OpenCV

```{python}
# Filtros espaciales
blur3 = cv2.blur(crop, (3,3))
gauss11 = cv2.GaussianBlur(crop, (11,11), 0)
median5 = cv2.medianBlur(crop, 5)

# Mostrar resultados
titles = ["Original", "Blur 3x3", "Gaussian 11x11", "Median 5"]
images = [crop, blur3, gauss11, median5]

plt.figure(figsize=(12,4))
for i, (img, title) in enumerate(zip(images, titles)):
    plt.subplot(1,4,i+1)
    plt.imshow(img, cmap='gray')
    plt.title(title)
    plt.axis('off')
plt.show()
```

---

## Comparaci√≥n visual y an√°lisis

- El filtro **blur** suaviza pero genera p√©rdida de detalle.  
- El filtro **gaussiano** suaviza de forma m√°s natural.  
- El filtro **mediana** elimina ruido tipo ‚Äúsal y pimienta‚Äù y preserva bordes.  

---

## Aprende üìö

Consulta y toma notas de los siguientes materiales:

- Peguero N√∫√±ez, P. D. [Realce y restauraci√≥n de im√°genes](https://www.lpi.tel.uva.es/muitic/pim/docus/Realce_y_restauracion.pdf)  
- Gim√©nez-Palomares, F. et al. (2016). [Convoluci√≥n y filtrado de im√°genes](https://polipapers.upv.es/index.php/MSEL/article/download/4524/4724)  
- Le√≥n-Batallas, A. et al. (2020). [Revisi√≥n de m√©tricas](https://recimundo.com/index.php/es/article/view/874/1372)  
- Mazet, V. (2021). [Histogram transformations](https://vincmazet.github.io/bip/digital-images/transformations.html)  
- Mazet, V. (2021). [Filtering](https://vincmazet.github.io/bip/digital-images/filtering.html)  
- OpenCV. (s.f.). [Operaciones aritm√©ticas](https://docs.opencv.org/3.4/d0/d86/tutorial_py_image_arithmetics.html)  

---

## Conclusi√≥n

- El **histograma** describe la distribuci√≥n de intensidades.  
- La **ecualizaci√≥n** mejora el contraste redistribuyendo los niveles.  
- Los **filtros espaciales** suavizan o reducen ruido:  
  - Media ‚Üí suaviza m√°s, pero pierde bordes.  
  - Gaussiano ‚Üí transici√≥n suave, natural.  
  - Mediana ‚Üí preserva bordes, elimina ruido impulsivo.  
- Comprender la **matem√°tica de matrices y convoluci√≥n** es clave para usar y dise√±ar filtros.  
